package org.bzdev.docsig.verify;
import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.security.Signature;
import java.security.Key;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.MessageDigest;
import java.security.spec.*;

import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;
import java.util.zip.*;

import org.bzdev.io.AppendableWriter;
import org.bzdev.net.*;
import org.bzdev.util.ACMatcher;
import org.bzdev.util.ACMatcher.MatchResult;

/**
 * Class for parsing and verifying messages created by
 * a Docsig server. Methods allow both message contents
 * and mbox-formatted files containing multiple messages.
 * <P>
 * These message represent signatures applied to simple
 * documents (text files, PDF files, etc.). A Docsig
 * server will provide a public key used to prove that
 * a specific part of the contents of an email were
 * generated by the server.
 */
public class DocsigVerifier {

    static final Charset UTF8 = Charset.forName("UTF-8");
    static final String CRLF = "\r\n";

    private static ACMatcher matcher = new
	ACMatcher(true, "From ",
		  "-----BEGIN DOCUMENT SIGNATURE DATA-----",
		  "-----END DOCUMENT SIGNATURE DATA-----",
		  "From: ",
		  "Message-ID: ",
		  "Content-Transfer-Encoding: ");

    private static enum State {
	START,
	FOUND_FROM,
	FOUND_BEGIN,
	FOUND_END
    }

    private static ACMatcher matcher2 = new ACMatcher("signature-algorithm: ");

    static final char[] hexArray = {
	'0','1','2','3','4','5','6','7','8','9',
	'a','b','c','d','e','f'};

    static String bytesToHex(byte[] bytes) {
	char[] hexChars = new char[bytes.length * 2];
	int v;
	for ( int j = 0; j < bytes.length; j++ ) {
	    v = bytes[j] & 0xFF;
	    hexChars[j * 2] = hexArray[v >>> 4];
	    hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	}
	return new String(hexChars);
    }

    static byte[] hexToBytes(String hexString) {
	int hlen = hexString.length();
	if (hlen % 2 == 1) return null;
	int len = hlen/2;
	byte[] bytes = new byte[len];
	for (int i = 0; i < len; i++) {
	    int hind1 = i*2;
	    int hind2 = hind1+1;
	    int hind3 = hind2+1;
	    String v1 = hexString.substring(hind1, hind2);         
	    String v2 = hexString.substring(hind2, hind3);
	    int bhigh = Integer.parseInt(v1, 16);
	    int blow = Integer.parseInt(v2, 16);
	    bytes[i] = (byte)((0xff) & (bhigh << 4 | blow));
	}
	return bytes;
    }


    static private MessageDigest createMD() {
	try {
	    return MessageDigest.getInstance("SHA-256");
	} catch (Exception e) {
	    return null;
	}
    }

    /*
     * Initialize with set of preferred providers.
     */
    private static HashMap<String,String> sigpmap = new HashMap<>();
    static {
	sigpmap.put("Sha256withECDSA", "SunEC");
    }

    private static HashMap<String,String> pmap = new HashMap<>();
    static {
	pmap.put("EC", "SunEC");
    }

    static private String[] headerKeys = {
	"acceptedBy", "date", "ipaddr", "id", "transID", "email",
	"server", "sendto", "document", "digest", "publicKeyID"
    };

    /**
     * Class providing results of parsing/verifying Docsig emails.
     */
    public static class Result {
	HeaderOps headers;
	String emailName;
	String emailAddr;
	String messageID;
	boolean status;

	/**
	 * Get Docsig headers.
	 * The header keys are
	 * <UL>
	 *   <LI><STRONG>acceptedBy</STRONG>. This is the name provided
	 *     by the individual signing the document.
	 *   <LI><STRONG>date</STRONG>. This is the date and time of day
	 *     at which the signature was generated by a Docsig server.
	 *   <LI><STRONG>ipaddr</STRONG>. This is the IP address of the
	 *      user or the last proxy when the signature-creation
	 *      request was sent to the server.
	 *   <LI><STRONG>id</STRONG>. This is field is optional. When
	 *      not null, it is an ID associated with the sender.
	 *   <LI><STRONG>transID</STRONG>. This is field is optional. When
	 *      not null, it is a transaction ID, typically by an entity
	 *      providing a user with a web page containing a form that
	 *      will generate a signature-creation request.
	 *   <LI><STRONG>email</STRONG>. This is the email address the user
	 *      intends to use. It should be the one the user registers with
	 *      the entity providing the document
	 *   <LI><STRONG>server</STRONG>. This is the URL for requests to a
	 *      Docsig server, whether sent with HTTP GET or POST methods.
	 *   <LI><STRONG>sendto</STRONG>. This is the email address of the
	 *      entity that will process signatures.
	 *   <LI><STRONG>document</STRONG>. This is the URL of the document
	 *      to sign.
	 *   <LI><STRONG>digest</STRONG>. This is a SHA-256 message digest
	 *      of the document that is to be signed.
	 *   <LI><STRONG>publicKeyID</STRONG>. This is the SHA-256
	 *      message digest of the public key used to sign the
	 *      values of these headers in the order shown above (a
	 *      string consisting of a carriage return followed by a
	 *      line feed is added to each value when these values are
	 *      signed).
	 * </UL>
	 * To obtain the value of a key, call the {@link HeaderOps} method
	 * {@link HeaderOps#getFirst(String) getFirst}. This method
	 * returns a {@link String} containing the value for the key
	 * (also a {@link String}) passed as <CODE>getFirst</CODE>'s
	 * sole argument.
	 * <P>
	 * Two additional headers are available:
	 * <UL>
	 *   <LI><STRONG>signature</STRONG>.
	 *   <LI><STRONG>signature-algorithm</STRONG>.
	 * </UL>
	 * These are used by the implementation.
	 * @return the headers
	 */
	public HeaderOps getHeaders() {return headers;}
	/**
	 * Get the name associated with an email (e.g., a name
	 * provided by the contents of the "From:" header.
	 * @return the name
	 */
	public String getEmailName() {return emailName;}
	/**
	 * Get the email address of the sender. This is obtained
	 * from the initial 'From ' header in a message.
	 * @return the address
	 */
	public String getEmailAddr() {return emailAddr;}
	/**
	 * Get the Email message ID for an email
	 * @return the message ID
	 */
	public String getMessageID() {return messageID;}
	/**
	 * Get the status for this email.
	 * 
	 * @return true if the message was verified; false otherwise
	 */
	public boolean getStatus() {return status;}

	Result(HeaderOps headers, String emailName, String emailAddr,
	       String messageID, boolean status)
	{
	    this.headers = headers;
	    this.emailName = emailName;
	    this.emailAddr = emailAddr;
	    this.messageID = messageID;
	    this.status = status;
	}
    }

    private static Result decode(String emailName, String emailAddr,
				 String messageID,
				 String s, PrintWriter ew)
	throws IOException
    {
	boolean status = true;
	PemDecoder.Result result = PemDecoder.decode(s);
	byte[] bytes = result.getBytes();
	InputStream is = new ByteArrayInputStream(bytes);
	is = new GZIPInputStream(is, bytes.length);
	Reader r = new InputStreamReader(is, UTF8);
	StringBuilder sb = new StringBuilder(2048);
	Writer w = new AppendableWriter(sb);
	r.transferTo(w);
	w.flush(); w.close();
	String firstDecoded = sb.toString();
	// System.out.println("**************");
	// System.out.print(sb.toString());
	// System.out.println("**************");
	String publicKeyPEM = null;
	for (MatchResult mr2: matcher2.iterableOver(firstDecoded)) {
	    int ind = mr2.getStart();
	    if (ind > 2 && firstDecoded.charAt(ind-1) == '\n'
		&& firstDecoded.charAt(ind-2) == '\r') {
		publicKeyPEM = firstDecoded.substring(ind);
		break;
	    }
	}
	MessageDigest md = createMD();
	md.update(publicKeyPEM.getBytes(UTF8));
	String pd = bytesToHex(md.digest());

	result = PemDecoder.decode(firstDecoded);
	HeaderOps headers = result.getHeaders();
	if (!pd.equals(headers.getFirst("publicKeyID"))) {
	    // bad input.
	    if (ew != null) {
		ew.println("For messageID: " + messageID + ",");
		ew.println("    bad PEM");
	    }
	    status = false;
	}
	try {
	    URL url = new URL(headers.getFirst("server")
			      + "?hasKeyRequest=" + pd);
	    URLConnection urlc = url.openConnection();
	    if (urlc instanceof HttpURLConnection) {
		urlc.connect();
		HttpURLConnection hurlc = (HttpURLConnection) urlc;
		switch (hurlc.getResponseCode()) {
		case 200:
		    break;
		case 404:
		    if (ew != null) {
			ew.println("For messageID: " + messageID + ",");
			ew.println("    public key not recognized by server");
		    }
		    status = false;
		    break;
		case 422:
		    if (ew != null) {
			ew.println("For messageID: " + messageID + ",");
			ew.println("    bad request to server");
		    }
		    status = false;
		    break;
		case 501:
		    if (ew != null) {
			ew.println("For messageID: " + messageID + ",");
			ew.println("    Public keys not available at server");
		    }
		    status = false;
		    break;
		}
	    }
	} catch (IOException e) {
	    if (ew != null) {
		ew.println("For messageID: " + messageID + ",");
		ew.println("    could not contact server: "
			   +  e.getMessage());
	    }
	    status = false;
	}
	// System.out.println();
				       
					   
	try {
	    SecureBasicUtilities sbutils =
		new SecureBasicUtilities(firstDecoded);
	    Signature verifier = sbutils.getVerifier();
	    for (String name: headerKeys) {
		String value = headers.getFirst(name);
		if (value != null) {
		    verifier.update((value + CRLF).getBytes(UTF8));
		}
	    }
	    String signatureStr = headers.getFirst("signature");
	    if (signatureStr != null) {
		byte[] signature = hexToBytes(signatureStr);
		if (!verifier.verify(signature)) {
		    if (ew != null) {
			ew.println("For messageID: " + messageID + ",");
			ew.println("    bad signature");
		    }
		    status  = false;
		} /* else {
		   System.out.println("signature OK");
		}
		  */
	    }
	} catch (GeneralSecurityException e) {
	    if (ew != null) {
		ew.println("For messageID: " + messageID + ",");
		ew.println("    signature-processing error");
	    }
	    status  = false;
	}
	/*
	System.out.println("emailName = " + emailName
			   + ", emailAddr = " + emailAddr);
	*/
	return new Result(headers, emailName, emailAddr, messageID, status);
    }


    /**
     * Decode multiple messages stored using mbox format, also
     * providing a {@link PrintWriter} for error messages.
     * @param r a {@link java.io.Reader} used to read an mbox file
     * @param ew a {@link java.io.PrintWriter} used to record error messages
     * @return an array of {@link Result} describing the status of
     *         a signature request and the values of various headers
     * @throws IOException if an IO error occurred
     */
    public static Result[] decodeFromMbox(Reader r, PrintWriter ew)
	throws IOException
    {
	if (ew == null) {
	    ew = new PrintWriter(new OutputStreamWriter(System.err));
	}
	StringBuilder sb = new StringBuilder(4096);
	AppendableWriter w = new AppendableWriter(sb);
	r.transferTo(w);
	w.flush(); w.close();
	State state = State.START;
	String buffer = sb.toString();
	int ind1 = 0;
	int ind2 = 0;
	ArrayList<Result> list = new ArrayList<>(256);
	String fromName = null;
	String fromEmail = null;
	String messageID = null;
	boolean quotedPrintable = false;
	for (MatchResult mr: matcher.iterableOver(buffer)) {
	    int index = mr.getIndex();
	    switch(state) {
	    case START:
		if (index == 0) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }

		    state = State.FOUND_FROM;
		    fromName = null;
		    messageID = null;
		    int ind = buffer.indexOf("\n", mr.getStart());
		    String s = buffer.substring(mr.getStart()+5, ind)
			.trim();
		    ind = s.indexOf(' ');
		    if (ind == -1) {
			fromEmail = s;
		    } else {
			fromEmail = s.substring(0, ind);
		    }
		}
		break;
	    case FOUND_FROM:
		if (index == 1) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }
		    state = State.FOUND_BEGIN;
		    ind1 = mr.getStart();
		} else if (index == 0) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }
		    state = State.FOUND_FROM;
		    fromName = null;
		    messageID = null;
		    int ind = buffer.indexOf("\n", mr.getStart());
		    String s = buffer.substring(mr.getStart()+5, ind)
			.trim();
		    ind = s.indexOf(' ');
		    if (ind == -1) {
			fromEmail = s;
		    } else {
			fromEmail = s.substring(0, ind);
		    }
		} else if (index == 3) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }
		    // found a "From: " header so just record
		    // info for cross checking.
		    int ind = buffer.indexOf("\n", mr.getStart());
		    if (ind != -1) {
			String s = buffer.substring(mr.getStart()+5, ind);
			int obind = s.indexOf('<');
			int cbind = s.indexOf('>');

			if (obind != -1 && cbind != -1) {
			    fromEmail = s.substring(obind+1, cbind).trim();
			    fromName = s.substring(0, obind).trim();
			} else {
			    fromEmail = s.trim();
			}
			// System.out.println("fromName = " + fromName);
		    }
		} else  if (index == 4) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }
		    // found a "Message-ID: " header so record its value
		    int ind = buffer.indexOf("\n", mr.getStart());
		    if (ind != -1  && messageID == null) {
			String s = buffer.substring(mr.getStart()+11, ind);
			int obind = s.indexOf('<');
			int cbind = s.indexOf('>');
			if (obind != -1 && cbind != -1) {
			    messageID = s.substring(obind+1, cbind);
			}
		    }
		} else if (index == 5) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }
		    // found a "Message-ID: " header so record its value
		    int ind = buffer.indexOf("\n", mr.getStart());
		    if (ind != -1) {
			String s = buffer.substring(mr.getEnd(), ind)
			    .trim().toLowerCase(Locale.US);
			quotedPrintable = s.equals("quoted-printable");
		    }
		}
		break;
	    case FOUND_BEGIN:
		if (index == 2) {
		    state = State.FOUND_END;
		    ind2 = mr.getEnd();
		    char ch = buffer.charAt(ind2);
		    if (ch == '\r') ind2++;
		    if (ch == '\n') ind2++;
		    String s = buffer.substring(ind1, ind2);
		    // System.out.println("s.length() = " + s.length());
		    // System.out.println(s);
		    if (quotedPrintable) {
			s = s.replace("=3D", "=");
		    }
		    Result result = decode(fromName, fromEmail, messageID,
					   s, ew);
		    list.add(result);
		} else {
		    // something is wrong, so reset
		    state = State.START;
		}
		break;
	    case FOUND_END:
		if (index == 0) {
		    int sind = mr.getStart();
		    if (sind > 0) {
			if (buffer.charAt(sind-1) != '\n') continue;
		    }
		    state = State.FOUND_FROM;
		    fromName = null;
		    messageID = null;
		    int ind = buffer.indexOf("\n", mr.getStart());
		    String s = buffer.substring(mr.getStart()+5, ind)
			.trim();
		    ind = s.indexOf(' ');
		    if (ind == -1) {
			fromEmail = s;
		    } else {
			fromEmail = s.substring(0, ind);
		    }
		}
	    }
	}
	Result[] array = new Result[list.size()];
	return list.toArray(array);
    }

    /**
     * Decode the contents of a Docsig message obtained from a {@link Reader}.
     * @param r a {@link Reader} that provides the message
     * @return a {@link Result} describing the status of
     *         a signature request and the values of various headers
     * @throws IOException if an IO error occurred
     */
    public static Result decodeFrom(Reader r)
	throws IOException
    {
	return decodeFrom(r, null);
    }

    /**
     * Decode the contents of a Docsig message obtained from a {@link Reader},
     * also providing a {@link PrintWriter} for error messages.
     * @param r a {@link java.io.Reader} used to read an mbox file
     * @param ew a {@link java.io.PrintWriter} used to record error messages
     * @return a {@link Result} describing the status of
     *         a signature request and the values of various headers
     * @throws IOException if an IO error occurred
     */
    public static Result decodeFrom(Reader r, PrintWriter ew)
	throws IOException
    {
	StringBuilder sb = new StringBuilder(4096);
	AppendableWriter w = new AppendableWriter(sb);
	r.transferTo(w);
	w.flush(); w.close();
	String s = sb.toString();
	return decodeFrom(s, ew);
    }

    /**
     * Decode the contents of a Docsig message obtained from a {@link String}.
     * @param s the string containing the contents of a Docsig message
     * @return a {@link Result} describing the status of
     *         a signature request and the values of various headers
     * @throws IOException if an IO error occurred
     */
    public static Result decodeFrom(String s)
	throws IOException
    {
	return decodeFrom(s, null);
    }

    /**
     * Decode the contents of a Docsig message obtained from a {@link String},
     * also providing a {@link PrintWriter} for error messages.
     * @param s the string containing the contents of a Docsig message
     * @param ew a {@link PrintWriter} used to record error messages
     * @return a {@link Result} describing the status of
     *         a signature request and the values of various headers
     * @throws IOException if an IO error occurred
     */
    public static Result decodeFrom(String s, PrintWriter ew)
	throws IOException
    {
	return decode(null, null, null, s, ew);
    }
}

//  LocalWords:  Docsig mbox UTF SHA Sha withECDSA SunEC acceptedBy
//  LocalWords:  ipaddr transID sendto publicKeyID  HeaderOps
//  LocalWords:  getFirst messageID PEM hasKeyRequest emailName ew
//  LocalWords:  emailAddr PrintWriter IOException fromName
